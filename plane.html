<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>S-plane &amp; Z-plane</title>
<style>

body {
    font-family: sans-serif;
}

svg {
    shape-rendering: optimizeSpeed
}

.drag {
    cursor: default;
}

.col {
    float: left;
}

.axis path,
.axis line {
    fill: none;
    stroke: #ccc;
}

.axis>text {
    font-size: 12px;
}

.tick>text {
    fill: #666;
    font-size: 11px;
}

.point {
    fill: orange;
}

.point.drag {
    filter: url(#drop-shadow);
}

.arc {
    fill: orange;
    fill-opacity: 0.3;
    stroke: none;
}

.distance {
    fill: none;
    stroke: orange;
    stroke-width: 1px;
}

.dashed{
    stroke: #999;
    stroke-width: 1px;
}

.dashed-label {
    fill: #999;
    font-size: 11px;
}

.unit-circle {
    fill: #f6f6f6;
    stroke: #ccc;
    stroke-width: 1px;
}

.left-part {
    fill: #f6f6f6;
    stroke: none;
}

.sine {
    fill: none;
    stroke: deeppink;
    stroke-width: 1px;
}

.cosine {
    fill: none;
    stroke: dodgerblue;
    stroke-width: 1px;
}

.re {
    color: dodgerblue;
}

.im {
    color: deeppink;
}

</style>
</head>
<body>
    <div class="col">
        <svg id="timeplot"></svg>
    </div>
    <div class="col">
        <svg id="s-plane"></svg>
        <p id="s-equation"></p>
    </div>
    <div class="col">
        <svg id="z-plane"></svg>
        <p id="z-equation"></p>
    </div>
    <p>
        Inspired by
     <a href="http://werner.yellowcouch.org/Papers/zvss">werner.yellowcouch.org/Papers/zvss</a>.
    </p>
    <script src="vendor/d3.v3.min.js" charset="utf-8"></script>
    <script src="util.js" charset="utf-8"></script>
    <script>

    'use strict'

    function createGraph(svg, width, height, margin) {
        svg.attr({
            width: width + margin + margin,
            height: height + margin + margin
        })
        return svg.append('g').attr('transform', translate(margin, margin))
    }


    function drawTimeplotLayout(graph, width, height, scale) {
        var xaxis = d3.svg.axis()
            .scale(scale.x)
            .innerTickSize(0)
            .outerTickSize(0)

        var yaxis = d3.svg.axis()
            .scale(scale.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, height/2))
            .call(xaxis)
            .call(xlabel, 'Time', width)

        graph.append('g')
            .attr('class', 'axis y-axis')
            .call(yaxis)

        graph.selectAll('.x-axis .tick')
            .filter(function (d, i) { return i === 0 })
            .remove()

        var clipped = graph.append('g').attr('clip-path', 'url(#clip)')
        clipped.append('path').attr('class', 'sine')
        clipped.append('path').attr('class', 'cosine')
    }


    function updateTimeplot(graph, data, line, real, imag) {
        graph.select('.cosine').attr('d', line(mapToFunc(data, real), scale))
        graph.select('.sine').attr('d', line(mapToFunc(data, imag), scale))
    }


    function drawZplaneLayout(graph, width, height, scale) {
        var xaxis = d3.svg.axis()
            .scale(scale.x)
            .innerTickSize(0)
            .outerTickSize(0)
            .tickValues([-1,1])

        var yaxis = d3.svg.axis()
            .scale(scale.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')
            .tickValues([-1,1])

        graph.append('ellipse').attr({
            class: 'unit-circle',
            cx: scale.x(0),
            cy: scale.y(0),
            rx: scale.x(1) - scale.x(0),
            ry: scale.y(0) - scale.y(1)
        })

        graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, height/2))
            .call(xaxis)
            .call(xlabel, 'Re(z)', width)

        graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(width/2, 0))
            .call(yaxis)
            .call(ylabel, 'Im(z)', 0)

        graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()
    }


    function drawPointVectors(graph, scale, points) {
        var origin = [scale.x(0), scale.y(0)]
        var x = function (d) { return scale.x(d[0]) }
        var y = function (d) { return scale.y(d[1]) }

        graph.selectAll('.distance').data(points)
            .attr('x2', x)
            .attr('y2', y)
            .enter()
                .append('line')
                .attr('class', 'distance')
                .attr('x1', origin[0])
                .attr('y1', origin[1])
                .attr('x2', x)
                .attr('y2', y)

        var arc = d3.svg.arc()
            .outerRadius(function(d) {
                var radius = distance(x(d) - origin[0], y(d) - origin[1])
                if (radius > 35) radius = 35
                return radius
            })
            .startAngle(function(d) {
                return Math.PI/2 - angle(d[0], d[1])
            })
            .endAngle(Math.PI/2)

        graph.selectAll('.arc').data(points)
            .attr('d', arc)
            .enter()
                .append('path')
                .attr('class', 'arc')
                .attr('d', arc)
                .attr('transform', translate(origin[0], origin[1]))
    }


    function drawSplaneLayout(graph, width, height, scale) {
        var xaxis = d3.svg.axis()
            .scale(scale.x)
            .innerTickSize(0)
            .outerTickSize(0)

        var yaxis = d3.svg.axis()
            .scale(scale.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        // add shaded area
        graph.append('rect').attr({
            class: 'left-part',
            x: 0,
            y: 0,
            width: width/2,
            height: height
        })

        // draw dashed lines to show pi, 2pi, -pi, -2pi
        var dashed = [
            { value: Math.PI, text: 'π' },
            { value: 2*Math.PI, text: '2π' },
            { value: -Math.PI, text: '-π' },
            { value: -2*Math.PI, text: '-2π' }
        ]

        graph.selectAll('.dashed').data(dashed).enter()
            .append('line')
                .attr('class', 'dashed')
                .attr('stroke-dasharray', '1,3')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', function(d) { return scale.y(d.value) })
                .attr('y2', function(d) { return scale.y(d.value) })

        graph.selectAll('.dashed-label').data(dashed).enter()
            .append('text')
                .attr('class', 'dashed-label')
                .attr('x', width)
                .attr('dx', 3)
                .attr('y', function(d) { return scale.y(d.value) })
                .text(function(d) { return d.text })

        // draw axes
        graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, height/2))
            .call(xaxis)
            .call(xlabel, 'Re(s)', width)

        graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(width/2, 0))
            .call(yaxis)
            .call(ylabel, 'Im(s)', 0)

        graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()
    }


    function drawPoints(graph, scale, points, drag) {
        var t = function (d) {
            return translate(scale.x(d[0]), scale.y(d[1]))
        }
        graph.selectAll('.point').data(points)
            .attr('transform', t)
            .enter()
                .append('circle')
                .attr('class', 'point')
                .attr('r', 5)
                .attr('transform', t)
                .call(drag)
    }



    ;(function () {

        var margin = 20
        var width =  (window.innerWidth - margin * 8) / 3
        var height = width



        var timeplot = {}
        timeplot.svg = d3.select('#timeplot')
        timeplot.time = d3.range(0, 10, 0.01)
        timeplot.scale = {}
        timeplot.scale.x = d3.scale.linear().domain([0, 10]).range([0, width])
        timeplot.scale.y = d3.scale.linear().domain([5, -5]).range([0, height])
        timeplot.graph = createGraph(timeplot.svg, width, height, margin)
        timeplot.line = line(timeplot.scale)

        clip(timeplot.svg, 'clip', width, height)
        drawTimeplotLayout(timeplot.graph, width, height, timeplot.scale)

        var splane = {}
        splane.svg = d3.select('#s-plane')
        splane.equation = document.getElementById('s-equation')
        splane.scale = {}
        splane.scale.x = d3.scale.linear().domain([-2, 2]).range([0, width])
        splane.scale.y = d3.scale.linear().domain([8, -8]).range([0, height])
        splane.graph = createGraph(splane.svg, width, height, margin)

        splane.drag = draggable(function (pos) {
            var s = []
            s[0] = splane.scale.x.invert(pos[0])
            s[1] = splane.scale.y.invert(pos[1])
            splane.update(s)
        })

        splane.svg.on('click', function () {
            if (d3.event.defaultPrevented) return
            var x = d3.event.offsetX - margin
            var y = d3.event.offsetY - margin
            var xi = splane.scale.x.invert(x)
            var yi = splane.scale.y.invert(y)
            drawPoints(splane.graph, splane.scale, [[xi, yi]], splane.drag)
            splane.update([xi, yi])
        })

        splane.update = function (s) {
            requestAnimationFrame(function () {
                // e^st = e^(x + yi)t
                var real = function (t) { return Math.exp(s[0]*t) * Math.cos(s[1]*t) }
                var imag = function (t) { return Math.exp(s[0]*t) * Math.sin(s[1]*t) }
                updateTimeplot(timeplot.graph, timeplot.time, timeplot.line, real, imag)

                var z = stoz(s)
                updateEquations(s, z)
                drawPoints(zplane.graph, zplane.scale, [z], zplane.drag)
                drawPointVectors(zplane.graph, zplane.scale, [z])
            })
        }

        createSvgShadow(splane.svg, 'drop-shadow')
        drawSplaneLayout(splane.graph, width, height, splane.scale)



        var zplane = {}
        zplane.svg = d3.select('#z-plane')
        zplane.equation = document.getElementById('z-equation')
        zplane.scale = {}
        zplane.scale.x = d3.scale.linear().domain([-1.5, 1.5]).range([0, width])
        zplane.scale.y = d3.scale.linear().domain([1.5, -1.5]).range([0, height])
        zplane.graph = createGraph(zplane.svg, width, height, margin)

        zplane.drag = draggable(function (pos) {
            var z = []
            z[0] = zplane.scale.x.invert(pos[0])
            z[1] = zplane.scale.y.invert(pos[1])
            zplane.update(z)
        })

        zplane.svg.on('click', function () {
            if (d3.event.defaultPrevented) return
            var x = d3.event.offsetX - margin
            var y = d3.event.offsetY - margin
            var xi = zplane.scale.x.invert(x)
            var yi = zplane.scale.y.invert(y)
            drawPoints(zplane.graph, zplane.scale, [[xi, yi]], zplane.drag)
            zplane.update([xi, yi])
        })

        zplane.update = function (z) {
            drawPointVectors(zplane.graph, zplane.scale, [z])
            requestAnimationFrame(function () {
                // z^t = A^t * e^ωit
                var A = distance(z[0], z[1]).toFixed(2)
                var w = angle(z[0], z[1]).toFixed(2)
                var real = function (t) { return Math.pow(A, t) * Math.cos(w*t) }
                var imag = function (t) { return Math.pow(A, t) * Math.sin(w*t) }
                updateTimeplot(timeplot.graph, timeplot.time, timeplot.line, real, imag)

                var s = ztos(z)
                updateEquations(s, z)
                drawPoints(splane.graph, splane.scale, [s], splane.drag)
            })
        }

        createSvgShadow(zplane.svg, 'drop-shadow')
        drawZplaneLayout(zplane.graph, width, height, zplane.scale)


        function updateEquations(s, z) {
            splane.equation.innerHTML = sequationHtml(s[0], s[1])
            zplane.equation.innerHTML = zequationHtml(z[0], z[1])
        }

        function sequationHtml(x, y) {
            x = x.toFixed(2)
            y = y.toFixed(2)
            return interpolate(
                's = &sigma; + i&omega;<br>' +
                'e<sup>st</sup> = e<sup>(&sigma; + i&omega;)t</sup>' +
                ' = e<sup>({} + i {})t</sup><br>' +
                'e<sup>st</sup> = <span class="re">e<sup>{}t</sup> cos({}t) </span>' +
                ' + <span class="im">e<sup>{}t</sup> sin({}t) i</span>',
                x, y, x, y, x, y
            )
        }

        function zequationHtml(x, y) {
            var A = distance(x, y).toFixed(2)
            var w = angle(x, y).toFixed(2)
            return interpolate(
                'z = Ae<sup>&omega;i</sup><br>' +
                'z<sup>t</sup> = A<sup>t</sup> e<sup>&omega;it</sup>' +
                ' = {}<sup>t</sup> e<sup>{}it</sup><br>' +
                'z<sup>t</sup> = <span class="re">{}<sup>t</sup> cos({}t)</span>' +
                ' + <span class="im">{}<sup>t</sup> sin({}t) i</span>',
                A, w, A, w, A, w
            )
        }

    })();


    // ----------------------- helpers -----------------------

    function clip(svg, id, width, height) {
        svg.append('defs')
            .append('svg:clipPath')
            .attr('id', id)
            .append('rect')
            .attr({ width: width, height: height })
    }

    function mapToFunc(data, func) {
        return data.map(function (x) { return [x, func(x)] })
    }

    function line(scale) {
        return d3.svg.line()
            .x(function (d) { return scale.x(d[0]) })
            .y(function (d) { return scale.y(d[1]) })
    }

    function xlabel(selection, text, pos) {
        selection.append('text')
            .attr('x', pos)
            .attr('y', -6)
            .style('text-anchor', 'end')
            .text(text)
    }

    function ylabel(selection, text, pos) {
        selection.append('text')
            .attr('transform', rotate(-90))
            .attr('x', pos)
            .attr('y', 6)
            .attr('dy', '.71em')
            .style('text-anchor', 'end')
            .text(text)
    }

    function distance(x, y) {
        return Math.sqrt(x*x + y*y)
    }

    function angle(x, y) {
        return Math.atan2(y, x)
    }

    function stoz(s) {
        // z = e^s
        return [
            Math.exp(s[0]) * Math.cos(s[1]),
            Math.exp(s[0]) * Math.sin(s[1])
        ]
    }

    function ztos(z) {
        // z = e^s
        // zx = e^sx * cos(sy)
        // zy = e^sx * sin(sy)
        // a = e^x * cos(y)
        // b = e^x * sin(y)
        // e^x = a / cos(y)
        // e^x = b / sin(y)
        // a / cos(y) = b / sin(y)
        // a = b cos(y) / sin(y)
        // cos(y) / sin(y) = a / b
        // sin(y) / cos(y) = b / a
        // tan(y) = b/a
        // y = atan(b/a)
        // e^x = a / cos(y)
        // x = ln(a / cos(y))
        var y = Math.atan2(z[1], z[0])
        return [
            Math.log(z[0] / Math.cos(y)), y
        ]
    }


    function draggable(callback) {

        function dragstart(d) {
            d3.event.sourceEvent.preventDefault()
            var el = d3.select(this)
            var transform = d3.transform(el.attr('transform'))
            var t = transform.translate
            d3.select(this).classed('drag', true)
                .attr('transform', translate(t[0], t[1]) + scale(1.3, 1.3))
        }

        function dragmove() {
            var el = d3.select(this)
            var x = d3.event.x
            var y = d3.event.y
            // this will center the object on the cursor, but it is not too noticeable
            // requestAnimationFrame(function () {
                el.attr('transform', translate(x, y) + scale(1.3, 1.3))
            // })
            return [x, y]
        }

        function dragend(d) {
            var el = d3.select(this)
            var transform = d3.transform(el.attr('transform'))
            var t = transform.translate
            el.classed('drag', false)
                .attr('transform', translate(t[0], t[1]) + scale(1, 1))
        }

        return d3.behavior.drag()
            .on('dragstart', dragstart)
            .on('drag', function (d,i) {
                var pos = dragmove.call(this, d, i)
                callback(pos)
            })
            .on('dragend', dragend)
    }

    </script>
</body>
</html>
