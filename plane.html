<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>S-plane &amp; Z-plane</title>
<style>

body {
    font-family: sans-serif;
}

svg {
    shape-rendering: optimizeSpeed
}

.drag {
    cursor: default;
}

.col {
    float: left;
}

.axis path,
.axis line {
    fill: none;
    stroke: #ccc;
}

.axis>text {
    font-size: 12px;
}

.tick>text {
    fill: #666;
    font-size: 11px;
}

.point {
    fill: orange;
}

.point.drag {
    filter: url(#drop-shadow);
}

.arc {
    fill: orange;
    fill-opacity: 0.3;
    stroke: none;
}

.distance {
    fill: none;
    stroke: orange;
    stroke-width: 1px;
}

.dashed{
    stroke: #999;
    stroke-width: 1px;
}

.dashed-label {
    fill: #999;
    font-size: 11px;
}

.unit-circle {
    fill: #f6f6f6;
    stroke: #ccc;
    stroke-width: 1px;
}

.left-part {
    fill: #f6f6f6;
    stroke: none;
}

.sine {
    fill: none;
    stroke: deeppink;
    stroke-width: 1px;
}

.cosine {
    fill: none;
    stroke: dodgerblue;
    stroke-width: 1px;
}

.re {
    color: dodgerblue;
}

.im {
    color: deeppink;
}

</style>
</head>
<body>
    <div class="col">
        <svg id="timeplot"></svg>
    </div>
    <div class="col">
        <svg id="s-plane"></svg>
        <p id="s-equation"></p>
    </div>
    <div class="col">
        <svg id="z-plane"></svg>
        <p id="z-equation"></p>
    </div>
    <p>
        Inspired by
     <a href="http://werner.yellowcouch.org/Papers/zvss">werner.yellowcouch.org/Papers/zvss</a>.
    </p>
    <script src="vendor/d3.v3.min.js" charset="utf-8"></script>
    <script src="util.js" charset="utf-8"></script>
    <script>

    'use strict'

    function Timeplot(svg, width, height, margin) {
        // setup scales ad axes
        this.time = d3.range(0, 10, 0.01)
        this.x = d3.scale.linear().domain([0, 10]).range([0, width])
        this.y = d3.scale.linear().domain([5, -5]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        this.svg = svg
        this.height = height
        this.width = width
        this.line = d3.svg.line()
            .x(function (d) { return this.x(d.x) })
            .y(function (d) { return this.y(d.y) })

        // draw graph
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.svg.append('defs')
            .append('svg:clipPath')
            .attr('id', 'clip')
            .append('rect')
            .attr({ width: this.width, height: this.height })

        this.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, this.height/2))
            .call(this.xaxis)
            .call(xlabel, 'Time', this.width)

        this.graph.append('g')
            .attr('class', 'axis y-axis')
            .call(this.yaxis)

        this.graph.selectAll('.x-axis .tick')
            .filter(function (d, i) { return i === 0 })
            .remove()

        var clipped = this.graph.append('g').attr('clip-path', 'url(#clip)')
        clipped.append('path').attr('class', 'sine')
        clipped.append('path').attr('class', 'cosine')
    }

    Timeplot.prototype.update = function (real, imag) {
        var cosine = this.time.map(function (t) { return { x: t, y: real(t) }})
        var sine = this.time.map(function (t) { return { x: t, y: imag(t) }})
        this.graph.select('.cosine').attr('d', this.line(cosine))
        this.graph.select('.sine').attr('d', this.line(sine))
    }



    function Zplane(svg, width, height, margin) {
        // make observable
        var dispatcher = d3.dispatch('update')
        d3.rebind(this, dispatcher, 'update', 'on')

        // setup
        this.x = d3.scale.linear().domain([-1.5, 1.5]).range([0, width])
        this.y = d3.scale.linear().domain([1.5, -1.5]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)
            .tickValues([-1,1])

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')
            .tickValues([-1,1])

        this.svg = svg
        this.margin = margin
        this.width = width
        this.height = height

        // draw graph
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.graph.append('ellipse').attr({
            class: 'unit-circle',
            cx: this.x(0),
            cy: this.y(0),
            rx: this.x(1) - this.x(0),
            ry: this.y(0) - this.y(1)
        })

        this.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, this.height/2))
            .call(this.xaxis)
            .call(xlabel, 'Re(z)', this.width)

        this.graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(this.width/2, 0))
            .call(this.yaxis)
            .call(ylabel, 'Im(z)', 0)

        this.graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()

        svg.on('click', function () {
            if (d3.event.defaultPrevented) return
            var x = d3.event.offsetX - this.margin
            var y = d3.event.offsetY - this.margin
            var xi = this.x.invert(x)
            var yi = this.y.invert(y)
            this.placePoint([xi, yi])
            this.update([xi, yi])
        }.bind(this))
    }

    Zplane.prototype.drawPointVectors = function (d) {
        var origin = [this.x(0), this.y(0)]
        var x = this.x(d[0])
        var y = this.y(d[1])

        this.graph.selectAll('.distance').data([d])
            .attr('x2', x)
            .attr('y2', y)
            .enter()
                .append('line')
                .attr('class', 'distance')
                .attr('x1', origin[0])
                .attr('y1', origin[1])
                .attr('x2', x)
                .attr('y2', y)


        var radius = distance(x - origin[0], y - origin[1])
        if (radius > 35) radius = 35

        var arc = d3.svg.arc()
            .outerRadius(function(d) { return d[1] })
            .startAngle(function(d) { return Math.PI/2-d[0] })
            .endAngle(Math.PI/2)


        this.graph.selectAll('.arc').data([[angle(d[0], d[1]), radius]])
            .attr('d', arc)
            .enter()
                .append('path')
                .attr('class', 'arc')
                .attr('d', arc)
                .attr('transform', translate(origin[0], origin[1]))
    }

    Zplane.prototype.placePoint = function (d) {
        var self = this
        var t = function (d) {
            return translate(self.x(d[0]), self.y(d[1]))
        }

        var drag = d3.behavior.drag()
            .on('dragstart', dragstart)
            .on('drag', function (d,i) {
                var pos = dragmove.call(this, d, i)
                pos[0] = self.x.invert(pos[0])
                pos[1] = self.y.invert(pos[1])
                self.update(pos)
                self.drawPointVectors(pos)
            })
            .on('dragend', dragend)

        this.drawPointVectors(d)
        this.graph.selectAll('.point').data([d])
            .attr('transform', t)
            .enter()
                .append('circle')
                .attr('class', 'point')
                .attr('r', 5)
                .attr('transform', t)
                .call(drag)
    }


    function Splane(svg, width, height, margin) {
        // make observable
        var dispatcher = d3.dispatch('update')
        d3.rebind(this, dispatcher, 'update', 'on')

        // setup scale & axes
        this.x = d3.scale.linear().domain([-2, 2]).range([0, width])
        this.y = d3.scale.linear().domain([8, -8]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        this.svg = svg
        this.height = height
        this.width = width
        this.margin = margin

        var self = this

        // draw graph
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.graph.append('rect').attr({
            class: 'left-part',
            x: 0,
            y: 0,
            width: this.width/2,
            height: this.height
        })

        var dashed = [
            { value: Math.PI, text: 'π' },
            { value: 2*Math.PI, text: '2π' },
            { value: -Math.PI, text: '-π' },
            { value: -2*Math.PI, text: '-2π' }
        ]

        // dashed lines to show pi, 2pi, -pi, -2pi
        this.graph.selectAll('.dashed').data(dashed).enter()
            .append('line')
                .attr('class', 'dashed')
                .attr('stroke-dasharray', '1,3')
                .attr('x1', 0)
                .attr('x2', self.width)
                .attr('y1', function(d) { return self.y(d.value) })
                .attr('y2', function(d) { return self.y(d.value) })

        this.graph.selectAll('.dashed-label').data(dashed).enter()
            .append('text')
                .attr('class', 'dashed-label')
                .attr('x', this.width)
                .attr('dx', 3)
                .attr('y', function(d) { return self.y(d.value) })
                .text(function(d) { return d.text })

        this.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, this.height/2))
            .call(this.xaxis)
            .call(xlabel, 'Re(s)', this.width)

        this.graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(this.width/2, 0))
            .call(this.yaxis)
            .call(ylabel, 'Im(s)', 0)

        this.graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()

        svg.on('click', function () {
            if (d3.event.defaultPrevented) return
            var x = d3.event.offsetX - this.margin
            var y = d3.event.offsetY - this.margin
            var xi = this.x.invert(x)
            var yi = this.y.invert(y)
            this.placePoint([xi, yi])
            this.update([xi, yi])
        }.bind(this))
    }

    Splane.prototype.placePoint = function (d) {
        var self = this
        var t = function (d) {
            return translate(self.x(d[0]), self.y(d[1]))
        }

        var drag = d3.behavior.drag()
            .on('dragstart', dragstart)
            .on('drag', function (d,i) {
                var pos = dragmove.call(this, d, i)
                pos[0] = self.x.invert(pos[0])
                pos[1] = self.y.invert(pos[1])
                self.update(pos)
            })
            .on('dragend', dragend)

        this.graph.selectAll('.point').data([d])
            .attr('transform', t)
            .enter()
                .append('circle')
                .attr('class', 'point')
                .attr('r', 5)
                .attr('transform', t)
                .call(drag)
    }

    Splane.prototype.getMousePosition = function (d) {
        var pos = {}
        pos.x = d3.event.pageX - this.margin - this.svg.node().offsetLeft
        pos.y = d3.event.pageY - this.margin - this.svg.node().offsetTop
        pos.xi = this.x.invert(pos.x)
        pos.yi = this.y.invert(pos.y)
        return pos
    }

    ;(function () {

        var margin = 20
        var width =  (window.innerWidth - margin * 8) / 3
        var height = width

        var splaneSvg = d3.select('#s-plane')
        var zplaneSvg = d3.select('#z-plane')
        var sequationEl = document.getElementById('s-equation')
        var zequationEl = document.getElementById('z-equation')

        createSvgShadow(splaneSvg, 'drop-shadow')
        createSvgShadow(zplaneSvg, 'drop-shadow')

        var splane = new Splane(splaneSvg, width, height, margin)
        var zplane = new Zplane(zplaneSvg, width, height, margin)
        var timeplot = new Timeplot(d3.select('#timeplot'), width, height, margin)

        splane.on('update', function(s) {
            requestAnimationFrame(function () {
                // e^st = e^(x + yi)t
                var real = function (t) { return Math.exp(s[0]*t) * Math.cos(s[1]*t) }
                var imag = function (t) { return Math.exp(s[0]*t) * Math.sin(s[1]*t) }
                timeplot.update(real, imag)

                var z = stoz(s)
                zplane.placePoint(z)
                sequationEl.innerHTML = sequationHtml(s[0], s[1])
                zequationEl.innerHTML = zequationHtml(z[0], z[1])
            })
        })


        zplane.on('update', function(z) {
            requestAnimationFrame(function () {
                // z^t = A^t * e^ωit
                var A = distance(z[0], z[1]).toFixed(2)
                var w = angle(z[0], z[1]).toFixed(2)
                var real = function (t) { return Math.pow(A, t) * Math.cos(w*t) }
                var imag = function (t) { return Math.pow(A, t) * Math.sin(w*t) }
                timeplot.update(real, imag)

                var s = ztos(z)
                splane.placePoint(s)
                sequationEl.innerHTML = sequationHtml(s[0], s[1])
                zequationEl.innerHTML = zequationHtml(z[0], z[1])
            })
        })

    })();


    // ----------------------- helpers -----------------------

    function xlabel(selection, text, pos) {
        selection.append('text')
            .attr('x', pos)
            .attr('y', -6)
            .style('text-anchor', 'end')
            .text(text)
    }

    function ylabel(selection, text, pos) {
        selection.append('text')
            .attr('transform', rotate(-90))
            .attr('x', pos)
            .attr('y', 6)
            .attr('dy', '.71em')
            .style('text-anchor', 'end')
            .text(text)
    }

    function dragstart(d) {
        d3.event.sourceEvent.preventDefault()
        var el = d3.select(this)
        var transform = d3.transform(el.attr('transform'))
        var t = transform.translate
        d3.select(this).classed('drag', true)
            .attr('transform', translate(t[0], t[1]) + scale(1.3, 1.3))
    }

    function dragmove() {
        var el = d3.select(this)
        var x = d3.event.x
        var y = d3.event.y
        // this will center the object on the cursor, but it is not too noticeable
        // requestAnimationFrame(function () {
            el.attr('transform', translate(x, y) + scale(1.3, 1.3))
        // })
        return [x, y]
    }

    function dragend(d) {
        var el = d3.select(this)
        var transform = d3.transform(el.attr('transform'))
        var t = transform.translate
        el.classed('drag', false)
            .attr('transform', translate(t[0], t[1]) + scale(1, 1))
    }

    function distance(x, y) {
        return Math.sqrt(x*x + y*y)
    }

    function angle(x, y) {
        return Math.atan2(y, x)
    }

    function stoz(s) {
        // z = e^s
        return [
            Math.exp(s[0]) * Math.cos(s[1]),
            Math.exp(s[0]) * Math.sin(s[1])
        ]
    }

    function ztos(z) {
        // z = e^s
        // zx = e^sx * cos(sy)
        // zy = e^sx * sin(sy)
        // a = e^x * cos(y)
        // b = e^x * sin(y)
        // e^x = a / cos(y)
        // e^x = b / sin(y)
        // a / cos(y) = b / sin(y)
        // a = b cos(y) / sin(y)
        // cos(y) / sin(y) = a / b
        // sin(y) / cos(y) = b / a
        // tan(y) = b/a
        // y = atan(b/a)
        // e^x = a / cos(y)
        // x = ln(a / cos(y))
        var y = Math.atan2(z[1], z[0])
        return [
            Math.log(z[0] / Math.cos(y)), y
        ]
    }

    function sequationHtml(x, y) {
        x = x.toFixed(2)
        y = y.toFixed(2)
        return interpolate(
            's = &sigma; + i&omega;<br>' +
            'e<sup>st</sup> = e<sup>(&sigma; + i&omega;)t</sup>' +
            ' = e<sup>({} + i {})t</sup><br>' +
            'e<sup>st</sup> = <span class="re">e<sup>{}t</sup> cos({}t) </span>' +
            ' + <span class="im">e<sup>{}t</sup> sin({}t) i</span>',
            x, y, x, y, x, y
        )
    }

    function zequationHtml(x, y) {
        var A = distance(x, y).toFixed(2)
        var w = angle(x, y).toFixed(2)
        return interpolate(
            'z = Ae<sup>&omega;i</sup><br>' +
            'z<sup>t</sup> = A<sup>t</sup> e<sup>&omega;it</sup>' +
            ' = {}<sup>t</sup> e<sup>{}it</sup><br>' +
            'z<sup>t</sup> = <span class="re">{}<sup>t</sup> cos({}t)</span>' +
            ' + <span class="im">{}<sup>t</sup> sin({}t) i</span>',
            A, w, A, w, A, w
        )
    }

    </script>
</body>
</html>
