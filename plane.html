<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>S-plane & Z-plane</title>
<style>

body {
    font-family: sans-serif;
}

.col {
    float: left;
}

.axis path,
.axis line {
    fill: none;
    stroke: #ccc;
}

.axis>text {
    font-size: 12px;
}

.tick>text {
    fill: #666;
    font-size: 11px;
}

.point {
    fill: orange;
}

.arc {
    fill: none;
    stroke: orange;
    stroke-width: 1px;
}

.distance {
    fill: none;
    stroke: orange;
    stroke-width: 1px;
}

.dashed{
    stroke: #999;
    stroke-width: 1px;
}

.dashed-label {
    fill: #999;
    font-size: 11px;
}

.unit-circle {
    fill: #f6f6f6;
    stroke: #ccc;
    stroke-width: 1px;
}

.left-part {
    fill: #f6f6f6;
    stroke: none;
}

.sine {
    fill: none;
    stroke: deeppink;
    stroke-width: 1px;
}

.cosine {
    fill: none;
    stroke: dodgerblue;
    stroke-width: 1px;
}

.re {
    color: dodgerblue;
}

.im {
    color: deeppink;
}


</style>
</head>
<body>
    <div class="col">
        <svg id="timeplot"></svg>
    </div>
    <div class="col">
        <svg id="s-plane"></svg>
        <p id="s-equation"></p>
    </div>
    <div class="col">
        <svg id="z-plane"></svg>
        <p id="z-equation"></p>
    </div>
    <p>
        Inspired by
     <a href="http://werner.yellowcouch.org/Papers/zvss">werner.yellowcouch.org/Papers/zvss</a>.
    </p>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="util.js" charset="utf-8"></script>
    <script>

    function Timeplot(svg, width, height, margin) {
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.time = d3.range(0, 10, 0.01)
        this.x = d3.scale.linear().domain([0, 10]).range([0, width])
        this.y = d3.scale.linear().domain([5, -5]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        this.svg = svg
        this.height = height
        this.width = width
        this.line = d3.svg.line()
            .x(function (d) { return this.x(d.x) })
            .y(function (d) { return this.y(d.y) })
    }

    Timeplot.prototype.update = function (real, imag) {
        var cosine = this.time.map(function (t) { return { x: t, y: real(t) }})
        var sine = this.time.map(function (t) { return { x: t, y: imag(t) }})
        this.graph.select('.cosine').attr('d', this.line(cosine))
        this.graph.select('.sine').attr('d', this.line(sine))
    }

    Timeplot.prototype.draw = function () {
        this.svg.append('defs')
            .append('svg:clipPath')
            .attr('id', 'clip')
            .append('rect')
            .attr({ width: this.width, height: this.height })

        this.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, this.height/2))
            .call(this.xaxis)
            .call(xlabel, 'Time', this.width)

        this.graph.append('g')
            .attr('class', 'axis y-axis')
            .call(this.yaxis)

        this.graph.selectAll('.x-axis .tick')
            .filter(function (d, i) { return i === 0 })
            .remove()

        var clipped = this.graph.append('g').attr('clip-path', 'url(#clip)')
        clipped.append('path').attr('class', 'sine')
        clipped.append('path').attr('class', 'cosine')
    }

    function Zplane(svg, width, height, margin) {
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.x = d3.scale.linear().domain([-1.5, 1.5]).range([0, width])
        this.y = d3.scale.linear().domain([1.5, -1.5]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)
            .tickValues([-1,1])

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')
            .tickValues([-1,1])

        this.svg = svg
        this.margin = margin
        this.width = width
        this.height = height
    }

    Zplane.prototype.getMousePosition = function () {
        var pos = {}
        pos.x = d3.event.pageX - this.margin - this.svg.node().offsetLeft
        pos.y = d3.event.pageY - this.margin - this.svg.node().offsetTop
        pos.xi = this.x.invert(pos.x)
        pos.yi = this.y.invert(pos.y)
        return pos
    }

    Zplane.prototype.placePoint = function (xi, yi) {
        var x = this.x(xi)
        var y = this.y(yi)

        this.graph.select('.point').attr('transform', translate(x, y))
        this.graph.select('.distance').attr({
            x1: this.x(0),
            y1: this.y(0),
            x2: x,
            y2: y
        })

        var ang = angle(this.x.invert(x), this.y.invert(y))
        var radius = distance(x - this.x(0), y - this.y(0))
        if (radius > 30) { radius = 30 }

        this.graph.select('.arc').attr('d', d3.svg.arc()
            .innerRadius(radius)
            .outerRadius(radius)
            .startAngle(Math.PI/2-ang)
            .endAngle(Math.PI/2)
        )
    }

    Zplane.prototype.draw = function (x, y) {
        this.graph.append('ellipse').attr({
            class: 'unit-circle',
            cx: this.x(0),
            cy: this.y(0),
            rx: this.x(1) - this.x(0),
            ry: this.y(0) - this.y(1)
        })

        this.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, this.height/2))
            .call(this.xaxis)
            .call(xlabel, 'Re(z)', this.width)

        this.graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(this.width/2, 0))
            .call(this.yaxis)
            .call(ylabel, 'Im(z)', 0)

        this.graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()

        this.graph.append('circle')
            .attr('class', 'point')
            .attr('r', 5)

        this.graph.append('line').attr('class', 'distance')
        this.graph.append('path')
            .attr('class', 'arc')
            .attr('transform', translate(this.x(0), this.y(0)))
    }


    function Splane(svg, width, height, margin) {
        svg.attr({ width: width+margin*2, height: height+margin*2 })
        this.graph = svg.append('g').attr('transform', translate(margin, margin))

        this.x = d3.scale.linear().domain([-2, 2]).range([0, width])
        this.y = d3.scale.linear().domain([8, -8]).range([0, height])

        this.xaxis = d3.svg.axis()
            .scale(this.x)
            .innerTickSize(0)
            .outerTickSize(0)

        this.yaxis = d3.svg.axis()
            .scale(this.y)
            .innerTickSize(0)
            .outerTickSize(0)
            .orient('left')

        this.svg = svg
        this.margin = margin
        this.width = width
        this.height = height
    }

    Splane.prototype.placePoint = function (xi, yi) {
        this.graph.select('.point').attr({
            cx: this.x(xi),
            cy: this.y(yi)
        })
    }

    Splane.prototype.getMousePosition = function () {
        var pos = {}
        pos.x = d3.event.pageX - this.margin - this.svg.node().offsetLeft
        pos.y = d3.event.pageY - this.margin - this.svg.node().offsetTop
        pos.xi = this.x.invert(pos.x)
        pos.yi = this.y.invert(pos.y)
        return pos
    }

    Splane.prototype.draw = function () {

        var self = this

        self.graph.append('rect').attr({
            class: 'left-part',
            x: 0,
            y: 0,
            width: self.width/2,
            height: self.height
        })

        var dashed = [
            { value: Math.PI, text: 'π' },
            { value: 2*Math.PI, text: '2π' },
            { value: -Math.PI, text: '-π' },
            { value: -2*Math.PI, text: '-2π' }
        ]

        // dashed lines to show pi, 2pi, -pi, -2pi
        self.graph.selectAll('.dashed').data(dashed).enter()
            .append('line')
                .attr('class', 'dashed')
                .attr('stroke-dasharray', '1,3')
                .attr('x1', 0)
                .attr('x2', self.width)
                .attr('y1', function(d) { return self.y(d.value) })
                .attr('y2', function(d) { return self.y(d.value) })

        self.graph.selectAll('.dashed-label').data(dashed).enter()
            .append('text')
            .attr('class', 'dashed-label')
            .attr('x', self.width)
            .attr('dx', 3)
            .attr('y', function(d) { return self.y(d.value) })
            .text(function(d) { return d.text })

        self.graph.append('g')
            .attr('class', 'axis x-axis')
            .attr('transform', translate(0, self.height/2))
            .call(self.xaxis)
            .call(xlabel, 'Re(s)', self.width)

        self.graph.append('g')
            .attr('class', 'axis y-axis')
            .attr('transform', translate(self.width/2, 0))
            .call(self.yaxis)
            .call(ylabel, 'Im(s)', 0)

        self.graph.selectAll('.axis .tick')
            .filter(function (d) { return d === 0 })
            .remove()

        self.graph.append('circle')
            .attr('class', 'point')
            .attr('r', 5)
    }


    function xlabel(selection, text, pos) {
        selection.append('text')
            .attr('x', pos)
            .attr('y', -6)
            .style('text-anchor', 'end')
            .text(text)
    }

    function ylabel(selection, text, pos) {
        selection.append('text')
            .attr('transform', rotate(-90))
            .attr('x', pos)
            .attr('y', 6)
            .attr('dy', '.71em')
            .style('text-anchor', 'end')
            .text(text)
    }

    function distance(x, y) {
        return Math.sqrt(x*x + y*y)
    }

    function angle(x, y) {
        return Math.atan2(y, x)
    }

    function stoz(x, y) {
        // z = e^s
        return {
            x: Math.exp(x) * Math.cos(y),
            y: Math.exp(x) * Math.sin(y)
        }
    }

    function ztos(x, y) {
        // z = e^s
        // zx = e^sx * cos(sy)
        // zy = e^sx * sin(sy)
        // a = e^x * cos(y)
        // b = e^x * sin(y)
        // e^x = a / cos(y)
        // e^x = b / sin(y)
        // a / cos(y) = b / sin(y)
        // a = b cos(y) / sin(y)
        // cos(y) / sin(y) = a / b
        // sin(y) / cos(y) = b / a
        // tan(y) = b/a
        // y = atan(b/a)
        // e^x = a / cos(y)
        // x = ln(a / cos(y))
        var sy = Math.atan2(y, x)
        return {
            x: Math.log(x / Math.cos(sy)),
            y: sy
        }
    }

    function sequationHtml(x, y) {
        x = x.toFixed(2)
        y = y.toFixed(2)
        return interpolate(
            's = &sigma; + i&omega;<br>' +
            'e<sup>st</sup> = e<sup>(&sigma; + i&omega;)t</sup>' +
            ' = e<sup>({} + i {})t</sup><br>' +
            'e<sup>st</sup> = <span class="re">e<sup>{}t</sup> cos({}t) </span>' +
            ' + <span class="im">e<sup>{}t</sup> sin({}t) i</span>',
            x, y, x, y, x, y
        )
    }

    function zequationHtml(x, y) {
        var A = distance(x, y).toFixed(2)
        var w = angle(x, y).toFixed(2)
        return interpolate(
            'z = Ae<sup>&omega;i</sup><br>' +
            'z<sup>t</sup> = A<sup>t</sup> e<sup>&omega;it</sup>' +
            ' = {}<sup>t</sup> e<sup>{}it</sup><br>' +
            'z<sup>t</sup> = <span class="re">{}<sup>t</sup> cos({}t)</span>' +
            ' + <span class="im">{}<sup>t</sup> sin({}t) i</span>',
            A, w, A, w, A, w
        )
    }


    (function () {

        var margin = 20
        var width =  (window.innerWidth - margin * 8) / 3
        var height = width

        var splaneSvg = d3.select('#s-plane')
        var zplaneSvg = d3.select('#z-plane')
        var sequationEl = document.getElementById('s-equation')
        var zequationEl = document.getElementById('z-equation')

        var splane = new Splane(splaneSvg, width, height, margin)
        var zplane = new Zplane(zplaneSvg, width, height, margin)
        var timeplot = new Timeplot(d3.select('#timeplot'), width, height, margin)

        splaneSvg.on('click', function () {
            var pos = splane.getMousePosition()
            var z = stoz(pos.xi, pos.yi)
            splane.placePoint(pos.xi, pos.yi)
            zplane.placePoint(z.x, z.y)

            // e^st = e^(x + yi)t
            var real = function (t) { return Math.exp(pos.xi*t) * Math.cos(pos.yi*t) }
            var imag = function (t) { return Math.exp(pos.xi*t) * Math.sin(pos.yi*t) }
            timeplot.update(imag, real)

            sequationEl.innerHTML = sequationHtml(pos.xi, pos.yi)
            zequationEl.innerHTML = zequationHtml(z.x, z.y)
        })

        zplaneSvg.on('click', function () {
            var pos = zplane.getMousePosition()
            var s = ztos(pos.xi, pos.yi)
            zplane.placePoint(pos.xi, pos.yi)
            splane.placePoint(s.x, s.y)

            // z^t = A^t * e^ωit
            var A = distance(pos.xi, pos.yi).toFixed(2)
            var w = angle(pos.xi, pos.yi).toFixed(2)
            var real = function (t) { return Math.pow(A, t) * Math.cos(w*t) }
            var imag = function (t) { return Math.pow(A, t) * Math.sin(w*t) }
            timeplot.update(imag, real)

            sequationEl.innerHTML = sequationHtml(s.x, s.y)
            zequationEl.innerHTML = zequationHtml(pos.xi, pos.yi)
        })

        splane.draw()
        zplane.draw()
        timeplot.draw()

    })();

    </script>
</body>
</html>
